<head>
    <style>
        * {
            margin: 0;
            padding: 0;
            font-family: Inconsolata;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        #content {
            font-stretch: extra-expanded;
            line-height: 16px;
            font: bold 16px Inconsolata;
        }
    </style>

    <Title> Arch Piano </Title>
</head>
<body id="body">

    <div>

        <h1 id="title" style="display:inline-block;">Arch Piano</h1>
        <!--<input type="text" placeholder="username" />-->
        <button id="connect" onclick="null"></button>
    </div>
    <script src="soundfont-player.min.js"></script>
    <script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>

    <canvas id='canvasBack' width='100%' height='100%'></canvas>

    <script type="text/javascript">


        let body = document.getElementById('title');
        body.onclick = function () {
            if (socket) {
                socket.emit('keyDown', 60);
            }
        }

        var socket = null;
        if (!socket) {
            console.log('init: no socket');
        }

        var userCount = 0;

        let b = document.getElementById('connect');
        b.onclick = connect;
        connect();
        function connect() {
            if (socket) {
                socket.off('keyUp')
                socket.off('keyDown')
                socket.disconnect();
                socket = null;
                b.innerText = 'Connect';
                console.log('click disconnect: ' + socket);
            } else {
                console.log('click connect');
                b.innerText = 'Disconnect';
                socket = io.connect();

                var room = window.location.pathname;
                socket.emit('joinRoom', room);

                console.log('socket connected');
                socket.on('keyDown', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyDown(key);
                    }
                });
                socket.on('keyUp', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyUp(key);
                    }
                });
                socket.on('userCount', function (data) {
                    userCount = data;
                });
            }
        }

        var instrument;
        Soundfont.instrument(new AudioContext(), 'acoustic_grand_piano').then(function (piano) {
            instrument = piano;
            console.log('soundfont registered: ' + piano);
        })

        let replay = [];
        let prevNotes = [];
        let nextNotes = [];
        let pressTime = {};
        let velocity = [];
        let lastPressedTime = [];
        let lastDownTime = [];
        let pressed = [];
        let node = [];
        let keyColor = [];


        function connectPiano(device) {
            device.onmidimessage = function (m) {
                const [command, key, velocity] = m.data;
                console.log('key event: ' + command + ', ' + key + ', ' + velocity);
                if (command === 144) {
                    keyDown(key, velocity);

                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyDown', key);
                    } else {
                        console.log('no socket');
                    }

                } else if (command === 128) {
                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyUp', key);
                    }

                    keyUp(key);
                }
            }
        }
        function keyDown(key, vel, local) {
            console.log('note down');

            if (vel) {
                velocity[key] = vel;
            }

            if (pressed[key]) {
                let now = new Date().getTime();
                addPrev(key, lastPressedTime[key], now);
            }

            //key down

            lastPressedTime[key] = new Date().getTime();
            pressed[key] = true;
            node[key] = instrument.play(key);

            keyColor[key] = `hsl(${360 * Math.random()}, 75%, 75%)`;
            console.log(key);
        }

        function keyUp(key) {
            console.log('key up');

            let now = new Date().getTime();
            addPrev(key, lastPressedTime[key], now, keyColor[key]);

            lastPressedTime[key] = now;
            //key up
            pressed[key] = false;
            if (node[key]) {
                node[key].stop();
            }

            console.log(key);
        }

        function addPrev(key, startTime, releaseTime, color) {
            prevNotes.push({ key: key, startTime: startTime, releaseTime: releaseTime, color: color });
        }

        navigator.requestMIDIAccess()
            .then(function (access) {
                console.log('access', access);
                access.onstatechange = function (e) {
                    connect();
                }
                connect();
                function connect() {

                    console.log('connecting all: ' + access.inputs.values());
                    let values = Array.from(access.inputs.values());
                    for (let i = 0; i < values.length; i++) {
                        console.log('connecting piano');
                        connectPiano(values[i]);
                    }
                }
            });


        let bpm = 60;
        let bps = bpm / 60;

        let canvas = document.getElementById('canvasBack');

        let ctx = canvas.getContext('2d');

        window.requestAnimationFrame(update);

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let ticks = 0;
        

        function update() {
            var time = new Date().getTime();
            //ctx.drawImage(background, 0, 0);
            ctx.fillStyle = 'rgb(255, 128, 128)';

            ctx.fillRect(0, 0, width, height);


            ctx.fillStyle = 'black';
            ctx.fillText('watchers: ' + userCount, 16, 16);

            ticks += 2;

            ctx.font = `${16}px Inconsolata`;
            ctx.textAlign = "center";
            ctx.fillStyle = 'white';

            //Render next notes
            for (let i = 0; i < nextNotes.length; i++) {
                let n = nextNotes[i];
                if (time - n.startTime < 5000) {
                    //console.log(n);
                    renderBarAbove(n.key, n.startTime, n.releaseTime)
                } else {
                    break;
                }
            }
            //Render previous notes
            for (let i = prevNotes.length - 1; i > -1; i--) {
                let n = prevNotes[i];
                if (time - n.releaseTime < 5000) {
                    //console.log(n);
                    renderBarBelow(n.key, n.startTime, n.releaseTime, n.color)
                } else {
                    break;
                }
            }
            //Render all the keys
            for (let i = 1; i < 9; i++) {
                [0, 2, 4, 5, 7, 9, 11, 1, 3, 6, 10]
                    .forEach(note => renderKey(i * 12 + note, i, note));
            }

            function getKeyInfo(key, octave, note) {
                let width = 24;
                let height = 120;
                let flatHeight = 60;
                let left = (octave * width * 7);

                switch (note) {
                    case 0://C
                        left += 0;
                        name = 'C';
                        break;
                    case 1://C#
                        left += width / 2;
                        height = flatHeight;
                        name = 'C#';
                        break;
                    case 2://D
                        left += width;
                        name = 'D';
                        break;
                    case 3://D#
                        left += (width * 3) / 2;
                        height = flatHeight;
                        name = 'D#';
                        break;
                    case 4://E
                        left += width * 2;
                        name = 'E';
                        break;
                    case 5://F
                        left += width * 3;
                        name = 'F';
                        break;
                    case 6://F#
                        left += (width * 7) / 2;
                        height = flatHeight;
                        name = 'F#';
                        break;
                    case 7://G
                        left += width * 4;
                        name = 'G';
                        break;
                    case 8://G#
                        left += (width * 9) / 2;
                        height = flatHeight;
                        name = 'G#';
                        break;
                    case 9://A
                        left += width * 5;
                        name = 'A';
                        break;
                    case 10://A#
                        left += (width * 11) / 2;
                        height = flatHeight;
                        name = 'A#';
                        break;
                    case 11://B
                        left += width * 6;
                        name = 'B';
                        break;
                }
                return [left, height, name];
            }

            function renderKey(key, octave, note) {
                let width = 24;
                let top = 480;

                let left, height, name;
                [left, height, name] = getKeyInfo(key, octave, note);
                if (pressed[key]) {
                    //key outlines
                    ctx.fillStyle = 'rgb(255, 51, 102)';
                    ctx.fillRect(left, top, width, height);

                    //pressed key color
                    ctx.fillStyle = 'rgb(255, 255, 255)';
                    ctx.fillRect(left + 2, top + 2, width - 4, height - 4);

                    //name the keys
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillText(name, left + 12, top + height - 6);

                    //Key highlight
                    let lastTime = lastPressedTime[key];
                    let recent = 100;
                    if (velocity[key]) {
                        recent = 100 - velocity[key];
                    }


                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = 'rgba(128, 128, 128, ' + ((recent - (time - lastTime)) / recent) + ')';

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);

                    }
                    //Piano falling colors
                    ctx.fillStyle = keyColor[key];
                    //Bar under key
                    ctx.fillRect(left, top + height, width, (time - lastTime) * bps * 160 / 1000);
                } else {

                    //key outlines
                    ctx.fillStyle = 'black';
                    ctx.fillRect(left, top, width, height);

                    //name the keys
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillText(name, left + 12, top + height - 6);

                    //unpressed key color
                    ctx.fillStyle = 'rgb(255, 51, 102)';
                    ctx.fillRect(left + 2, top + 2, width - 4, height - 4);


                    let lastTime = lastPressedTime[key];
                    let recent = 100;
                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = 'rgba(128, 128, 128, ' + ((recent - (time - lastTime)) / recent) + ')';

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);
                    }

                    //Piano Text
                    ctx.fillStyle = 'white';
                    ctx.fillText(name, left + 12, top + height - 6);
                }
            }

            function renderBarBelow(key, startTime, releaseTime, color) {
                let octave = Math.floor(key / 12);
                let note = key % 12;
                let width = 24;
                let top = 480;

                let left, height, name;
                [left, height, name] = getKeyInfo(key, octave, note);

                ctx.fillStyle = color;
                ctx.fillRect(left,
                    top + height + (time - releaseTime) * bps * 160 / 1000,
                    width,
                    (releaseTime - startTime) * bps * 160 / 1000,
                );
            }

            window.requestAnimationFrame(update);
        }

    </script>
</body>