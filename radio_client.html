<head>
    <style>
        * {
            margin: 0;
            padding: 0;
            font-family: Inconsolata;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        #content {
            font-stretch: extra-expanded;
            line-height: 16px;
            font: bold 16px Inconsolata;
        }

        #canvasBack {
            width:100%;
            height:100%;
        }
    </style>

    <title> Piano Radio </title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>
<body id="body">

    <div>
        <div style="margin-left:32px; float:left;">
            <h1 id="title">Piano Radio - A piano on the internet</h1>
            <h2 id="needMidi">You must connect a MIDI device to play</h2>

            <h2 id="roomName"></h2>
            <button id="defaultRoom" onclick="null">Default Room</button>
            <button id="createRoom" onclick="null">Create Room</button>
            <!--<input type="text" placeholder="username" />-->
            <button id="connect" onclick="null" hidden="hidden"></button>
        </div>
        <div style="margin-right:32px; float:right;">

            <h1 id="audioOn">Click to enable audio</h1>
        </div>
    </div>
    
    <hr style="margin:0px 0px 0px 0px; border:0px; height:4px; clear:both;" />
    <canvas id='canvasBack'></canvas>

    <script src="soundfont-player.min.js"></script>
    <script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>
    <script type="text/javascript">

        {
            let root = 0,
                second = 2,
                third = 4,
                fourth = 5,
                fifth = 7,
                sixth = 9,
                seventh = 11

            let keyC = [root, second, third, fourth, fifth, sixth, seventh];

            let I = [root, third, fifth];
            let i = [root, third - 1, fifth];
            let ii = [second, fourth, sixth];
            let iii = [third, fifth, seventh];
            let IV = [fourth, sixth, root];
            let iv = [fourth, sixth - 1, root];
            let V = [fifth, seventh, second];
            let v = [fifth, seventh - 1, second];
            let vi = [sixth, root, third];
            let vii = [seventh, second, fourth];

            let keyNames = [
                'C',
                'C#',
                'D',
                'D#',
                'E',
                'F',
                'G',
                'G#',
                'A',
                'A#',
                'B'
            ]
            let chords = {
                'I': I,
                'i': i,
                'ii': ii,
                'iii': iii,
                'IV': IV,
                'iv': iv,
                'V': V,
                'v': v,
                'vi': vi,
                'vii': vii
            };

            function matchesKey(keyArray, notes) {
                return notes.every(n => keyArray.includes(n));
            }
            function matchesChord(chordArray, notes) {
                return notes.every(n => chordArray.includes(n));
            }
            function getKeyArray(keyBase) {
                return keyC.map(n => (n + keyBase) % 12);
            }
            function findKey(notes) {
                let matchCount = 0;
                let matchKey = -1;
                for (let keyBase = 0; keyBase < 12; keyBase++) {
                    let keyArray = getKeyArray(keyBase);
                    let count = notes.filter(n => keyArray.includes(n % 12));
                    if (count > matchCount) {
                        matchCount = count;
                        matchKey = keyBase;
                    }
                }
                return matchKey;
            }
            function getChordArray(keyBase, chordArrayBase) {
                return chordArrayBase.map(n => (n + keyBase) % 12);
            }
            function findChord(keyBase, notes) {
                let matchCount = 0;
                let matchChord = null;
                for (let chordName in Object.keys(chords)) {
                    let chord = chords[chordName];
                    let chordArray = getChordArray(keyBase, chord);
                    let count = notes.filter(n => chordArray.includes(n % 12));
                    if (count > matchCount) {
                        matchCount = count;
                        matchChord = chordName;
                    }
                }
                if (matchCount != notes.count) {

                }
            }

            let currentKey = 'I';
        }

        let createRoom = $('#createRoom');
        createRoom.click(function () {
            var rand = Math.floor(Math.random() * 1000000);
            var link = window.location.origin;
            link = link + '/' + rand;
            window.location.href = link;
        });

        let defaultRoom = $('#defaultRoom');
        defaultRoom.click(function () {
            var link = window.location.origin;
            window.location.href = link;
        });

        let body = $('#body');
        body.click(function () {
            $('#audioOn').text('Audio enabled');
        });

        var socket = null;
        if (!socket) {
            console.log('init: no socket');
        }

        let pianoConnected = false;

        var userCount = 0;


        let roomName = $('#roomName');
        let b = $('#connect');
        b.click(connect);
        connect();
        function connect() {
            if (socket) {
                socket.off('keyUp')
                socket.off('keyDown')
                socket.disconnect();
                socket = null;
                b.text('Connect');
                console.log('click disconnect: ' + socket);
            } else {
                console.log('click connect');
                b.text('Disconnect');
                socket = io.connect();

                var room = window.location.pathname;
                socket.emit('joinRoom', room);

                if (room == '/') {
                    roomName.text('You are in the default room.');
                } else {
                    roomName.text('You are in room ' + room.replace('/', ''));
                }

                console.log('socket connected');
                socket.on('keyDown', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyDown(key);
                    }
                });
                socket.on('keyUp', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyUp(key);
                    }
                });
                socket.on('userCount', function (data) {
                    userCount = data;
                });
            }
        }


        let needMidi = $('#needMidi');
        function updatePiano() {
            if (pianoConnected) {
                needMidi.text("MIDI device connected.");
            } else {

                needMidi.text("You must connect a MIDI device to play");
            }
        }


        var instrument;
        Soundfont.instrument(new AudioContext(), 'acoustic_grand_piano').then(function (piano) {
            instrument = piano;
            console.log('soundfont registered: ' + piano);
        })

        let replay = [];
        let prevNotes = [];
        let nextNotes = [];
        let pressTime = {};
        let velocity = [];
        let lastPressedTime = [];
        let lastDownTime = [];
        let pressed = [];
        let node = [];
        let keyColor = [...Array(12 * 8).keys()].map(key =>
            key % 12 == 0 ? 'rgb(255, 255, 255)' :
            `hsl(${8 * (360) * key / (12 * 8)}, 75%, 75%)`
        );


        function connectPiano(device) {

            device.onmidimessage = function (m) {
                const [command, key, velocity] = m.data;
                console.log('key event: ' + command + ', ' + key + ', ' + velocity);
                if (command === 144) {
                    keyDown(key, velocity);

                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyDown', key);
                    } else {
                        console.log('no socket');
                    }

                } else if (command === 128) {
                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyUp', key);
                    }

                    keyUp(key);
                }
            }
        }
        function keyDown(key, vel, local) {
            console.log('note down');

            if (vel) {
                velocity[key] = vel;
            }

            if (pressed[key]) {
                let now = new Date().getTime();
                addPrev(key, lastPressedTime[key], now);
            }

            //key down

            lastPressedTime[key] = new Date().getTime();
            pressed[key] = true;
            node[key] = instrument.play(key);

            //keyColor[key] = `hsl(${360 * Math.random()}, 75%, 75%)`;
            console.log(key);
        }

        function keyUp(key) {
            console.log('key up');

            let now = new Date().getTime();
            addPrev(key, lastPressedTime[key], now, keyColor[key]);

            lastPressedTime[key] = now;
            //key up
            pressed[key] = false;
            if (node[key]) {
                node[key].stop();
            }

            console.log(key);
        }

        function addPrev(key, startTime, releaseTime, color) {
            prevNotes.push({ key: key, startTime: startTime, releaseTime: releaseTime, color: color });
        }

        navigator.requestMIDIAccess()
            .then(function (access) {
                console.log('access', access);
                access.onstatechange = function (e) {
                    connect();
                }
                connect();
                function connect() {

                    console.log('connecting all: ' + access.inputs.values());
                    let values = Array.from(access.inputs.values());
                    for (let i = 0; i < values.length; i++) {
                        console.log('connecting piano');
                        connectPiano(values[i]);
                    }

                    pianoConnected = values.length > 0;
                    updatePiano();
                }
            });


        let bpm = 60;
        let bps = bpm / 60;

        let canvas = document.getElementById('canvasBack');

        let ctx = canvas.getContext('2d');

        window.requestAnimationFrame(update);

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let ticks = 0;


        function update() {
            var time = new Date().getTime();
            //ctx.drawImage(background, 0, 0);
            ctx.fillStyle = 'rgb(255, 128, 128)';

            ctx.fillRect(0, 0, width, height);


            ctx.font = `${16}px Inconsolata`;
            ctx.textAlign = "left";
            ctx.fillStyle = 'black';
            ctx.fillText('watchers: ' + userCount, 16, 16);

            ticks += 2;

            ctx.font = `${16}px Inconsolata`;
            ctx.textAlign = "center";
            ctx.fillStyle = 'white';

            //Render next notes
            for (let i = 0; i < nextNotes.length; i++) {
                let n = nextNotes[i];
                if (time - n.startTime < 5000) {
                    //console.log(n);
                    renderBarAbove(n.key, n.startTime, n.releaseTime)
                } else {
                    break;
                }
            }
            
            //Render all the keys
            for (let i = 1; i < 9; i++) {
                [0, 2, 4, 5, 7, 9, 11, 1, 3, 6, 8, 10]
                    .forEach(note => renderKey(i * 12 + note, i, note));
            }
            //Render previous notes
            for (let i = prevNotes.length - 1; i > -1; i--) {
                let n = prevNotes[i];
                if (time - n.releaseTime < 5000) {
                    //console.log(n);
                    renderBarBelow(n.key, n.startTime, n.releaseTime, n.color)
                } else {
                    break;
                }
            }


            function getKeyInfo(key, octave, note) {
                let width = 24;
                let height = 120;
                let flatWidth = width * 3 / 4;
                let flatHeight = height/2;
                let left = (octave * width * 7);
                let flat = false;
                switch (note) {
                    case 0://C
                        left += 0;
                        name = 'C';
                        break;
                    case 1://C#
                        left += width / 2;
                        width = flatWidth;
                        height = flatHeight;
                        name = 'C#';
                        flat = true;
                        break;
                    case 2://D
                        left += width;
                        name = 'D';
                        break;
                    case 3://D#
                        left += (width * 3) / 2 + width/4;
                        width = flatWidth;
                        height = flatHeight;
                        name = 'D#';
                        flat = true;
                        break;
                    case 4://E
                        left += width * 2;
                        name = 'E';
                        break;
                    case 5://F
                        left += width * 3;
                        name = 'F';
                        break;
                    case 6://F#
                        left += (width * 7) / 2;
                        width = flatWidth;
                        height = flatHeight;
                        name = 'F#';
                        flat = true;
                        break;
                    case 7://G
                        left += width * 4;
                        name = 'G';
                        break;
                    case 8://G#
                        left += (width * 9) / 2 + width/8;
                        width = flatWidth;
                        height = flatHeight;
                        name = 'G#';
                        flat = true;
                        break;
                    case 9://A
                        left += width * 5;
                        name = 'A';
                        break;
                    case 10://A#
                        left += (width * 11) / 2 + width/4;
                        width = flatWidth;
                        height = flatHeight;
                        name = 'A#';
                        flat = true;
                        break;
                    case 11://B
                        left += width * 6;
                        name = 'B';
                        break;
                }
                return [left, width, height, name, flat];
            }

            function renderKey(key, octave, note) {
                let top = 120;

                let left, width, height, name, flat;
                [left, width, height, name, flat] = getKeyInfo(key, octave, note);


                let unpressedColor = flat ? '51, 102, 102' : '255, 51, 102';
                if (pressed[key]) {
                    //key outlines
                    ctx.fillStyle = `rgb(${unpressedColor})`;
                    ctx.fillRect(left, top, width, height);

                    //pressed key color
                    ctx.fillStyle = 'rgb(255, 255, 255)';
                    ctx.fillRect(left + 2, top + 2, width - 4, height - 4);

                    //name the keys
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillText(name, left + 12, top + height - 6);

                    //Key highlight
                    let lastTime = lastPressedTime[key];
                    let recent = 125;
                    if (velocity[key]) {
                        recent = recent - velocity[key];
                    }

                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = `rgba(${unpressedColor}, ${((recent - (time - lastTime)) / recent)})`;

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);
                    }
                    //Piano falling colors
                    ctx.fillStyle = keyColor[key];
                    //Bar under key
                    ctx.fillRect(left, top + height, width, (time - lastTime) * bps * 160 / 1000);
                } else {

                    //key outlines
                    ctx.fillStyle = 'black';
                    ctx.fillRect(left, top, width, height);

                    //name the keys
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillText(name, left + 12, top + height - 6);

                    //unpressed key color
                    /*
                    if (pianoConnected) {

                        ctx.fillStyle = 'rgb(255, 51, 102)';
                    } else {
                        ctx.fillStyle = 'rgb(128, 128, 128)';
                    }
                    */

                    ctx.fillStyle = `rgb(${unpressedColor})`;

                    ctx.fillRect(left + 2, top + 2, width - 4, height - 4);


                    //Unpress fade color
                    let lastTime = lastPressedTime[key];
                    let recent = 125;
                    if (velocity[key]) {
                        recent = recent - velocity[key];
                    }
                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${((recent - (time - lastTime)) / recent)})`;

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);
                    }

                    //Piano Text
                    ctx.fillStyle = 'white';
                    ctx.fillText(name, left + 12, top + height - 6);
                }
            }

            function renderBarBelow(key, startTime, releaseTime, color) {
                let octave = Math.floor(key / 12);
                let note = key % 12;
                let top = 120;

                let left, width, height, name;
                [left, width, height, name] = getKeyInfo(key, octave, note);

                ctx.fillStyle = color;
                ctx.fillRect(left,
                    top + height + (time - releaseTime) * bps * 160 / 1000,
                    width,
                    (releaseTime - startTime) * bps * 160 / 1000,
                );
            }

            window.requestAnimationFrame(update);
        }

    </script>
</body>