<head>
    <style>
        * {
            margin: 0;
            padding: 0;
            font-family: Inconsolata;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        #content {
            font-stretch: extra-expanded;
            line-height: 16px;
            font: bold 16px Inconsolata;
        }
    </style>

    <title> Piano Radio </title>
</head>
<body id="body">
    <div style="margin-left:16px;">
        <h1 id="title">Piano Radio - A piano on the internet</h1>
        <h2 id="needMidi">You must connect a MIDI device to play</h2>
        <h2 id="roomName"></h2>
        <button id="createRoom" onclick="null">Create Room</button>
        <!--<input type="text" placeholder="username" />-->
        <button id="connect" onclick="null" hidden="hidden"></button>
    </div>
    <script src="soundfont-player.min.js"></script>
    <script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>

    <canvas id='canvasBack' width='100%' height='100%'></canvas>

    <script type="text/javascript">
        let root = 0,
            second = 2,
            third = 4,
            fourth = 5,
            fifth = 7,
            sixth = 9,
            seventh = 11

        let keyC = [root, second, third, fourth, fifth, sixth, seventh];

        let I = [root, third, fifth];
        let i = [root, third - 1, fifth];
        let ii = [second, fourth, sixth];
        let iii = [third, fifth, seventh];
        let IV = [fourth, sixth, root];
        let iv = [fourth, sixth - 1, root];
        let V = [fifth, seventh, second];
        let v = [fifth, seventh - 1, second];
        let vi = [sixth, root, third];
        let vii = [seventh, second, fourth];

        let keyNames = [
            'C',
            'C#',
            'D',
            'D#',
            'E',
            'F',
            'G',
            'G#',
            'A',
            'A#',
            'B'
        ]
        let chords = {
            'I': I,
            'i': i,
            'ii': ii,
            'iii': iii,
            'IV': IV,
            'iv': iv,
            'V': V,
            'v': v,
            'vi': vi,
            'vii': vii
        };

        function matchesKey(keyArray, notes) {
            return notes.every(n => keyArray.includes(n));
        }
        function matchesChord(chordArray, notes) {
            return notes.every(n => chordArray.includes(n));
        }
        function getKeyArray(keyBase) {
            return keyC.map(n => (n + keyBase) % 12);
        }
        function findKey(notes) {
            let matchCount = 0;
            let matchKey = -1;
            for (let keyBase = 0; keyBase < 12; keyBase++) {
                let keyArray = getKeyArray(keyBase);
                let count = notes.filter(n => keyArray.includes(n % 12));
                if (count > matchCount) {
                    matchCount = count;
                    matchKey = keyBase;
                }
            }
            return matchKey;
        }
        function getChordArray(keyBase, chordArrayBase) {
            return chordArrayBase.map(n => (n + keyBase) % 12);
        }
        function findChord(keyBase, notes) {
            let matchCount = 0;
            let matchChord = null;
            for (let chordName in Object.keys(chords)) {
                let chord = chords[chordName];
                let chordArray = getChordArray(keyBase, chord);
                let count = notes.filter(n => chordArray.includes(n % 12));
                if (count > matchCount) {
                    matchCount = count;
                    matchChord = chordName;
                }
            }
            if (matchCount != notes.count) {

            }
        }

        let currentKey = 'I';


        let createRoom = document.getElementById('createRoom');
        body.onclick = function () {
            var rand = Math.floor(Math.random() * 1000000);
            var link = "https://pianoradio-1.silentsonar.repl.co/" + rand;
            window.location.href = link;

        }

        /*
        let body = document.getElementById('title');
        body.onclick = function () {
            if (socket) {
                socket.emit('keyDown', 60);
            }
        }
        */

        var socket = null;
        if (!socket) {
            console.log('init: no socket');
        }

        let pianoConnected = false;

        var userCount = 0;


        let roomName = document.getElementById('roomName');
        let b = document.getElementById('connect');
        b.onclick = connect;
        connect();
        function connect() {
            if (socket) {
                socket.off('keyUp')
                socket.off('keyDown')
                socket.disconnect();
                socket = null;
                b.innerText = 'Connect';
                console.log('click disconnect: ' + socket);
            } else {
                console.log('click connect');
                b.innerText = 'Disconnect';
                socket = io.connect();

                var room = window.location.pathname;
                socket.emit('joinRoom', room);

                if (room == '') {
                    roomName.innerText = 'You are in the default room.';
                } else {
                    roomName.innerText = 'You are in room ' + room;
                }

                console.log('socket connected');
                socket.on('keyDown', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyDown(key);
                    }
                });
                socket.on('keyUp', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyUp(key);
                    }
                });
                socket.on('userCount', function (data) {
                    userCount = data;
                });
            }
        }


        let needMidi = document.getElementById('needMidi');
        function updatePiano() {
            if (pianoConnected) {
                needMidi.innerText = "MIDI device connected";
            } else {

                needMidi.innerText = "You must connect a MIDI device to play";
            }
        }


        var instrument;
        Soundfont.instrument(new AudioContext(), 'acoustic_grand_piano').then(function (piano) {
            instrument = piano;
            console.log('soundfont registered: ' + piano);
        })

        let replay = [];
        let prevNotes = [];
        let nextNotes = [];
        let pressTime = {};
        let velocity = [];
        let lastPressedTime = [];
        let lastDownTime = [];
        let pressed = [];
        let node = [];
        let keyColor = [];


        function connectPiano(device) {
            
            device.onmidimessage = function (m) {
                const [command, key, velocity] = m.data;
                console.log('key event: ' + command + ', ' + key + ', ' + velocity);
                if (command === 144) {
                    keyDown(key, velocity);

                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyDown', key);
                    } else {
                        console.log('no socket');
                    }

                } else if (command === 128) {
                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyUp', key);
                    }

                    keyUp(key);
                }
            }
        }
        function keyDown(key, vel, local) {
            console.log('note down');

            if (vel) {
                velocity[key] = vel;
            }

            if (pressed[key]) {
                let now = new Date().getTime();
                addPrev(key, lastPressedTime[key], now);
            }

            //key down

            lastPressedTime[key] = new Date().getTime();
            pressed[key] = true;
            node[key] = instrument.play(key);

            keyColor[key] = `hsl(${360 * Math.random()}, 75%, 75%)`;
            console.log(key);
        }

        function keyUp(key) {
            console.log('key up');

            let now = new Date().getTime();
            addPrev(key, lastPressedTime[key], now, keyColor[key]);

            lastPressedTime[key] = now;
            //key up
            pressed[key] = false;
            if (node[key]) {
                node[key].stop();
            }

            console.log(key);
        }

        function addPrev(key, startTime, releaseTime, color) {
            prevNotes.push({ key: key, startTime: startTime, releaseTime: releaseTime, color: color });
        }

        navigator.requestMIDIAccess()
            .then(function (access) {
                console.log('access', access);
                access.onstatechange = function (e) {
                    connect();
                }
                connect();
                function connect() {

                    console.log('connecting all: ' + access.inputs.values());
                    let values = Array.from(access.inputs.values());
                    for (let i = 0; i < values.length; i++) {
                        console.log('connecting piano');
                        connectPiano(values[i]);
                    }

                    pianoConnected = values.length > 0;
                    updatePiano();
                }
            });


        let bpm = 60;
        let bps = bpm / 60;

        let canvas = document.getElementById('canvasBack');

        let ctx = canvas.getContext('2d');

        window.requestAnimationFrame(update);

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let ticks = 0;
        

        function update() {
            var time = new Date().getTime();
            //ctx.drawImage(background, 0, 0);
            ctx.fillStyle = 'rgb(255, 128, 128)';

            ctx.fillRect(0, 0, width, height);


            ctx.font = `${16}px Inconsolata`;
            ctx.textAlign = "left";
            ctx.fillStyle = 'black';
            ctx.fillText('watchers: ' + userCount, 16, 16);

            ticks += 2;

            ctx.font = `${16}px Inconsolata`;
            ctx.textAlign = "center";
            ctx.fillStyle = 'white';

            //Render next notes
            for (let i = 0; i < nextNotes.length; i++) {
                let n = nextNotes[i];
                if (time - n.startTime < 5000) {
                    //console.log(n);
                    renderBarAbove(n.key, n.startTime, n.releaseTime)
                } else {
                    break;
                }
            }
            //Render previous notes
            for (let i = prevNotes.length - 1; i > -1; i--) {
                let n = prevNotes[i];
                if (time - n.releaseTime < 5000) {
                    //console.log(n);
                    renderBarBelow(n.key, n.startTime, n.releaseTime, n.color)
                } else {
                    break;
                }
            }
            //Render all the keys
            for (let i = 1; i < 9; i++) {
                [0, 2, 4, 5, 7, 9, 11, 1, 3, 6, 10]
                    .forEach(note => renderKey(i * 12 + note, i, note));
            }

            function getKeyInfo(key, octave, note) {
                let width = 24;
                let height = 120;
                let flatHeight = 60;
                let left = (octave * width * 7);

                switch (note) {
                    case 0://C
                        left += 0;
                        name = 'C';
                        break;
                    case 1://C#
                        left += width / 2;
                        height = flatHeight;
                        name = 'C#';
                        break;
                    case 2://D
                        left += width;
                        name = 'D';
                        break;
                    case 3://D#
                        left += (width * 3) / 2;
                        height = flatHeight;
                        name = 'D#';
                        break;
                    case 4://E
                        left += width * 2;
                        name = 'E';
                        break;
                    case 5://F
                        left += width * 3;
                        name = 'F';
                        break;
                    case 6://F#
                        left += (width * 7) / 2;
                        height = flatHeight;
                        name = 'F#';
                        break;
                    case 7://G
                        left += width * 4;
                        name = 'G';
                        break;
                    case 8://G#
                        left += (width * 9) / 2;
                        height = flatHeight;
                        name = 'G#';
                        break;
                    case 9://A
                        left += width * 5;
                        name = 'A';
                        break;
                    case 10://A#
                        left += (width * 11) / 2;
                        height = flatHeight;
                        name = 'A#';
                        break;
                    case 11://B
                        left += width * 6;
                        name = 'B';
                        break;
                }
                return [left, height, name];
            }

            function renderKey(key, octave, note) {
                let width = 24;
                let top = 120;

                let left, height, name;
                [left, height, name] = getKeyInfo(key, octave, note);
                if (pressed[key]) {
                    //key outlines
                    ctx.fillStyle = 'rgb(255, 51, 102)';
                    ctx.fillRect(left, top, width, height);

                    //pressed key color
                    ctx.fillStyle = 'rgb(255, 255, 255)';
                    ctx.fillRect(left + 2, top + 2, width - 4, height - 4);

                    //name the keys
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillText(name, left + 12, top + height - 6);

                    //Key highlight
                    let lastTime = lastPressedTime[key];
                    let recent = 100;
                    if (velocity[key]) {
                        recent = 100 - velocity[key];
                    }

                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = 'rgba(128, 128, 128, ' + ((recent - (time - lastTime)) / recent) + ')';

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);
                    }
                    //Piano falling colors
                    ctx.fillStyle = keyColor[key];
                    //Bar under key
                    ctx.fillRect(left, top + height, width, (time - lastTime) * bps * 160 / 1000);
                } else {

                    //key outlines
                    ctx.fillStyle = 'black';
                    ctx.fillRect(left, top, width, height);

                    //name the keys
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillText(name, left + 12, top + height - 6);

                    //unpressed key color
                    /*
                    if (pianoConnected) {

                        ctx.fillStyle = 'rgb(255, 51, 102)';
                    } else {
                        ctx.fillStyle = 'rgb(128, 128, 128)';
                    }
                    */

                    ctx.fillStyle = 'rgb(255, 51, 102)';

                    ctx.fillRect(left + 2, top + 2, width - 4, height - 4);

                    let lastTime = lastPressedTime[key];
                    let recent = 100;
                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = 'rgba(128, 128, 128, ' + ((recent - (time - lastTime)) / recent) + ')';

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);
                    }

                    //Piano Text
                    ctx.fillStyle = 'white';
                    ctx.fillText(name, left + 12, top + height - 6);
                }
            }

            function renderBarBelow(key, startTime, releaseTime, color) {
                let octave = Math.floor(key / 12);
                let note = key % 12;
                let width = 24;
                let top = 120;

                let left, height, name;
                [left, height, name] = getKeyInfo(key, octave, note);

                ctx.fillStyle = color;
                ctx.fillRect(left,
                    top + height + (time - releaseTime) * bps * 160 / 1000,
                    width,
                    (releaseTime - startTime) * bps * 160 / 1000,
                );
            }

            window.requestAnimationFrame(update);
        }

    </script>
</body>