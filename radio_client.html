<head>
    <style>
        * {
            margin: 0;
            padding: 0;

            font-family: Inconsolata;
        }
        html, body {
            width: 100%;
            height: 100%;
        }
        #content {
            font-stretch:extra-expanded;
            line-height:16px;
            font:bold 16px Inconsolata;
        }

    </style>
</head>
<body id="body">
    <div >

        <h1 id="title" style="display:inline-block;">Port 88</h1>
        <input type="text" placeholder="username" />
        <button  id="connect"  onclick="null"></button>
    </div>
    <script src="soundfont-player.min.js"></script>
    <script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>

    <canvas id='canvasBack' width='100%' height='100%'></canvas>

    <script type="text/javascript">


        let body = document.getElementById('title');
        body.onclick = function () {
            if (socket) {
                socket.emit('keyDown', 60);
            }
        }

        var socket = null;
        if(!socket) {
          console.log('init: no socket');
        }

        let b = document.getElementById('connect');
        b.onclick = connect;
        connect();
        function connect() {
            if (socket) {
                socket.off('keyUp')
                socket.off('keyDown')
                socket.disconnect();
                socket = null;
                b.innerText = 'Connect';
                console.log('click disconnect: ' + socket);
            } else {
                console.log('click connect');
                b.innerText = 'Disconnect';
                socket = io.connect();
                console.log('socket connected');
                socket.on('keyDown', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyDown(key);
                    }
                });
                socket.on('keyUp', function (key) {
                    console.log(key);
                    if (instrument) {
                        keyUp(key);
                    }
                });
            }
        }

        var instrument;
        Soundfont.instrument(new AudioContext(), 'acoustic_grand_piano').then(function (piano) {
            instrument = piano;
            console.log('soundfont registered: ' + piano);
        })

        let replay = [];
        let prevNotes = [];
        let pressTime = {};
        let velocity = [];
        let lastPressedTime = [];
        let lastDownTime = [];
        let pressed = [];
        let node = [];

        function connectPiano(device) {
            device.onmidimessage = function (m) {
                const [command, key, velocity] = m.data;
                console.log('key event: ' + command + ', ' + key + ', ' + velocity);
                if (command === 144) {
                    keyDown(key, velocity);

                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyDown', key);
                    } else {
                      console.log('no socket');
                    }

                } else if (command === 128) {
                    if (socket) {
                        console.log('sending key ' + key);
                        socket.emit('keyUp', key);
                    }

                    keyUp(key);
                }
            }
        }
        function keyDown(key, vel, local) {

            console.log('note down');

            if (vel) {
                velocity[key] = vel;
            }

            if (pressed[key]) {
                let now = new Date().getTime();
                addPrev(key, lastPressedTime[key], now);
            }

            //key down

            lastPressedTime[key] = new Date().getTime();
            pressed[key] = true;
            node[key] = instrument.play(key);


            console.log(key);
        }

        function keyUp(key) {
            console.log('key up');


            let now = new Date().getTime();
            addPrev(key, lastPressedTime[key], now);

            lastPressedTime[key] = now;
            //key up
            pressed[key] = false;
            if (node[key]) {
                node[key].stop();
            }

            console.log(key);
        }

        function addPrev(key, startTime, releaseTime) {
            prevNotes.push({ number: key, startTime: startTime, releaseTime: releaseTime });
        }

        navigator.requestMIDIAccess()
            .then(function (access) {
                console.log('access', access);
                access.onstatechange = function (e) {
                    connect();
                }
                connect();
                function connect() {

                    console.log('connecting all: ' + access.inputs.values());
                    let values = Array.from(access.inputs.values());
                    for (let i = 0; i < values.length; i++) {
                        console.log('connecting piano');
                        connectPiano(values[i]);
                    }
                }
            });


        let bpm = 60;
        let bps = bpm / 60;

        let canvas = document.getElementById('canvasBack');


        let ctx = canvas.getContext('2d');

        window.requestAnimationFrame(update);

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let ticks = 0;
        function update() {
            var time = new Date().getTime();

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, width, height);

            ticks += 2;

            ctx.font = `${16}px Inconsolata`;
            ctx.textAlign = "center";
            ctx.fillStyle = 'white';

            for (let i = prevNotes.length - 1; i > -1; i--) {
                let n = prevNotes[i];
                if (time - n.releaseTime < 5000) {
                    
                    //console.log(n);
                    renderBar(n.number, n.startTime, n.releaseTime)
                } else {
                    break;
                }
            }
            for (let i = 1; i < 7; i++) {
                [0, 2, 4, 5, 7, 9, 11, 1, 3, 6, 10]
                    .forEach(note => renderNote(i * 12 + note, i, note));
            }
            function renderNote(number, octave, note) {
                let width = 24;
                let left = octave * (width) * 7;
                let top = 480;
                let height = 120;
                let flatHeight = 60;
                let name = '';
                switch (note) {
                    case 0://C
                        left += 0;
                        name = 'C';
                        break;
                    case 1://C#
                        left += width / 2;
                        height = flatHeight;
                        name = 'C#';
                        break;
                    case 2://D
                        left += width;
                        name = 'D';
                        break;
                    case 3://D#
                        left += (width * 3) / 2;
                        height = flatHeight;
                        name = 'D#';
                        break;
                    case 4://E
                        left += width * 2;
                        name = 'E';
                        break;
                    case 5://F
                        left += width * 3;
                        name = 'F';
                        break;
                    case 6://F#
                        left += (width * 7) / 2;
                        height = flatHeight;
                        name = 'F#';
                        break;
                    case 7://G
                        left += width * 4;
                        name = 'G';
                        break;
                    case 8://G#
                        left += (width * 9) / 2;
                        height = flatHeight;
                        name = 'G#';
                        break;
                    case 9://A
                        left += width * 5;
                        name = 'A';
                        break;
                    case 10://A#
                        left += (width * 11) / 2;
                        height = flatHeight;
                        name = 'A#';
                        break;
                    case 11://B
                        left += width * 6;
                        name = 'B';
                        break;
                }

                ctx.fillStyle = 'white';
                ctx.fillRect(left, top, width, height);

                ctx.fillStyle = 'black';
                ctx.fillText(name, left + 12, top + height - 6);

                if (pressed[number]) {

                    //Key highlight
                    let lastTime = lastPressedTime[number];
                    let recent = 100;
                    if (velocity[number]) {
                        recent = 100 - velocity[number];
                    }


                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = 'rgba(128, 128, 128, ' + ((recent - (time - lastTime)) / recent) + ')';

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);

                    }
                    ctx.fillStyle = 'white';
                    //Bar under key
                    ctx.fillRect(left, top + height, width, (time - lastTime) * bps * 160 / 1000);
                } else {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(left + 2, top + 2, width - 4, height - 4);




                    let lastTime = lastPressedTime[number];
                    let recent = 100;
                    if (lastTime && (time - lastTime) < recent) {
                        ctx.fillStyle = 'rgba(128, 128, 128, ' + ((recent - (time - lastTime)) / recent) + ')';

                        ctx.fillRect(left + 2, top + 2, width - 4, height - 4);
                    }


                    ctx.fillStyle = 'white';
                    ctx.fillText(name, left + 12, top + height - 6);
                    



                }

            }

            function renderBar(number, startTime, releaseTime) {
                let octave = Math.floor(number / 12);
                let note = number % 12;
                let width = 24;
                let left = octave * (width) * 7;
                let top = 480;
                let height = 120;
                let flatHeight = 60;
                let name = '';
                switch (note) {
                    case 0://C
                        left += 0;
                        name = 'C';
                        break;
                    case 1://C#
                        left += width / 2;
                        height = flatHeight;
                        name = 'C#';
                        break;
                    case 2://D
                        left += width;
                        name = 'D';
                        break;
                    case 3://D#
                        left += (width * 3) / 2;
                        height = flatHeight;
                        name = 'D#';
                        break;
                    case 4://E
                        left += width * 2;
                        name = 'E';
                        break;
                    case 5://F
                        left += width * 3;
                        name = 'F';
                        break;
                    case 6://F#
                        left += (width * 7) / 2;
                        height = flatHeight;
                        name = 'F#';
                        break;
                    case 7://G
                        left += width * 4;
                        name = 'G';
                        break;
                    case 8://G#
                        left += (width * 9) / 2;
                        height = flatHeight;
                        name = 'G#';
                        break;
                    case 9://A
                        left += width * 5;
                        name = 'A';
                        break;
                    case 10://A#
                        left += (width * 11) / 2;
                        height = flatHeight;
                        name = 'A#';
                        break;
                    case 11://B
                        left += width * 6;
                        name = 'B';
                        break;
                }


                ctx.fillRect(left,
                    top + height + (time - releaseTime) * bps * 160 / 1000,
                    width,
                    (releaseTime - startTime) * bps * 160 / 1000,
                );
            }

            window.requestAnimationFrame(update);
        }

    </script>
</body>